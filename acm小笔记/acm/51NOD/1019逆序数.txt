思路：看的大神的，一开始傻傻的去暴力了。。后来知道用归并排序写的，先将一个数组分成尽量相等的两部分，递归一下，直到每一部分分为一个元素，然后开始回溯，将左右部分的最小元素比较，小的那个存入数组中，最后会形成一个已排序的数组（具体过程可以百度归并排序），在这个过程中我们发现一旦右边部分的元素存入时，那么他便会和此时左边的元素及其以后的元素形成逆序数，这时只要用一个变量记录即可。
--------------------- 
作者：gtuif 
来源：CSDN 
原文：https://blog.csdn.net/gtuif/article/details/73554735?utm_source=copy 
版权声明：本文为博主原创文章，转载请附上博文链接！

二叉树的思想
递归方程是一个逐渐积累的过程，并不是一个状态方程

如3=(1-0)+(1-0)+(1-0);非3=(3-0)
伪代码：
进入函数体：
函数终止条件
if(top>=tail)
函数进行
mid=(top+tail)/2;
左分半;
右分半;
int i=top;int j=tail;int m=mid+1;
/*以下是为了给左右两结点一起从小到大排好序，以及顺便统计ans */
while(i<=mid&&j<=tail){
if(左小于右)
{
	左边进temp容器；
}
else
{
	右边进temp容器;
	ans=ans+(mid+1-i);//+1是表示mid也属于逆序数统计的一部分
			因为mid前面部分已经从小到大排序了
}
}
左部分残余或者是右边部分残余，剩下的残余进容器
所以要
while(i<=mid) 左边残余进temp;
while(j<=tail) 右边残余进temp;
全部进入temp完毕，此时的temp整体部分已经是从小到大排序好，然后temp替换整个输入数组，进行下一次的归位
}
